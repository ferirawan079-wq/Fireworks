<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kembang Api</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #000; 
            overflow: hidden; 
            height: 100vh; 
            cursor: crosshair;
        }
        canvas { display: block; }
        .info { 
            position: absolute; 
            bottom: 20px; 
            width: 100%; 
            text-align: center; 
            color: rgba(255,255,255,0.7); 
            font-family: monospace; 
            font-size: 14px; 
            animation: fade 3s infinite alternate;
        }
        @keyframes fade {
            0% { opacity: 0.3; }
            100% { opacity: 0.8; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="info">Klik di mana saja</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let rockets = [];
        let explosions = [];
        let particles = [];

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        class Rocket {
            constructor(x, y, targetX, targetY) {
                this.x = x;
                this.y = y;
                this.targetX = targetX;
                this.targetY = targetY;
                this.speed = 0;
                this.maxSpeed = 8;
                this.acceleration = 0.2;
                this.size = 3;
                this.color = this.getColor();
                this.trail = [];
                this.active = true;
                this.angle = Math.atan2(targetY - y, targetX - x);
                this.distance = Math.sqrt((targetX - x) ** 2 + (targetY - y) ** 2);
                this.traveled = 0;
            }

            getColor() {
                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            update() {
                if (!this.active) return false;

                this.speed = Math.min(this.speed + this.acceleration, this.maxSpeed);
                const dx = Math.cos(this.angle) * this.speed;
                const dy = Math.sin(this.angle) * this.speed;
                
                this.x += dx;
                this.y += dy;
                this.traveled += Math.sqrt(dx * dx + dy * dy);

                this.trail.push({x: this.x, y: this.y});
                if (this.trail.length > 8) this.trail.shift();

                const distToTarget = Math.sqrt((this.targetX - this.x) ** 2 + (this.targetY - this.y) ** 2);
                
                if (distToTarget < 15 || this.traveled > this.distance) {
                    this.explode();
                    return true;
                }
                return false;
            }

            explode() {
                this.active = false;
                explosions.push(new Explosion(this.x, this.y, this.color));
                playSound();
            }

            draw() {
                if (!this.active) return;

                // Jejak
                for (let i = 0; i < this.trail.length; i++) {
                    const point = this.trail[i];
                    ctx.globalAlpha = i / this.trail.length;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, this.size * (i / this.trail.length), 0, Math.PI * 2);
                    ctx.fill();
                }

                // Roket
                ctx.globalAlpha = 1;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Badan roket
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.size, -this.size/2, this.size*2, this.size);

                // Api
                const gradient = ctx.createLinearGradient(-this.size*2, 0, -this.size*4, 0);
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(0.5, '#ff9900');
                gradient.addColorStop(1, '#ffff00');
                ctx.fillStyle = gradient;
                ctx.fillRect(-this.size*2, -this.size/2, this.size*3, this.size);

                ctx.restore();
            }
        }

        class Explosion {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.particles = [];
                this.createParticles();
            }

            createParticles() {
                const count = Math.floor(Math.random() * 100) + 80;
                
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 5 + 2;
                    this.particles.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: Math.random() * 4 + 1,
                        color: Math.random() > 0.3 ? this.color : ['#fff', '#ff0', '#0ff'][Math.floor(Math.random()*3)],
                        life: 1,
                        decay: Math.random() * 0.02 + 0.01
                    });
                }
            }

            update() {
                this.particles = this.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.05;
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                    p.life -= p.decay;
                    p.size *= 0.99;
                    return p.life > 0;
                });
            }

            draw() {
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
            }

            isDone() {
                return this.particles.length === 0;
            }
        }

        function playSound() {
            if (typeof AudioContext !== 'undefined') {
                const audio = new (AudioContext || webkitAudioContext)();
                const oscillator = audio.createOscillator();
                const gain = audio.createGain();
                
                oscillator.connect(gain);
                gain.connect(audio.destination);
                
                oscillator.frequency.value = 100;
                oscillator.frequency.exponentialRampToValueAtTime(50, audio.currentTime + 0.3);
                
                gain.gain.value = 0.2;
                gain.gain.exponentialRampToValueAtTime(0.01, audio.currentTime + 0.3);
                
                oscillator.start();
                oscillator.stop(audio.currentTime + 0.3);
            }
        }

        // Event listeners
        canvas.addEventListener('click', (e) => {
            rockets.push(new Rocket(
                Math.random() * canvas.width,
                canvas.height + 20,
                e.clientX,
                e.clientY
            ));
            document.querySelector('.info').style.opacity = '0';
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            rockets.push(new Rocket(
                Math.random() * canvas.width,
                canvas.height + 20,
                touch.clientX,
                touch.clientY
            ));
            document.querySelector('.info').style.opacity = '0';
        }, { passive: false });

        // Animasi
        function animate() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update dan gambar roket
            rockets = rockets.filter(rocket => {
                const arrived = rocket.update();
                rocket.draw();
                return !arrived;
            });

            // Update dan gambar ledakan
            explosions = explosions.filter(exp => {
                exp.update();
                exp.draw();
                return !exp.isDone();
            });

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        animate();

        // Kembang api otomatis
        setInterval(() => {
            if (rockets.length < 5) {
                rockets.push(new Rocket(
                    Math.random() * canvas.width,
                    canvas.height + 20,
                    Math.random() * canvas.width,
                    Math.random() * canvas.height * 0.7
                ));
            }
        }, 2000);
    </script>
</body>
</html>